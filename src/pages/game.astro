---
import MainLayout from '../layouts/MainLayout.astro';
---

<MainLayout
  title="Tetris"
  description="A classic Tetris game built with vanilla JavaScript and Canvas."
>
  <section class="space-y-8">
    <div class="max-w-4xl space-y-4">
      <p class="eyebrow">Game</p>
      <h1 class="section-title">Tetris</h1>
      <p class="lead">
        I've been hooked on Tetris since it shipped on the Game Boy in 1989. Semi-finalist at the 1994 Nintendo World Championships and never stopped chasing that perfect clear. Honestly, I just wanted a good version to play again — so I prompted it into existence.
      </p>
      <p class="text-textMuted text-sm mt-2">
        Arrow keys to move and rotate · Down for soft drop · Space to hard drop · C to hold
      </p>
    </div>

    <div class="grid gap-6 lg:grid-cols-[1fr,300px]">
      <div class="space-y-4">
        <div class="card flex items-center justify-center p-4">
          <div class="relative">
            <canvas id="tetris-canvas" width="300" height="600" class="rounded-lg tetris-playfield"></canvas>
            <div id="tspin-banner" class="tspin-banner" aria-live="polite">T-SPIN!</div>
          </div>
        </div>

        <div id="touch-controls" class="touch-controls" aria-label="Touch controls">
          <button type="button" data-action="left">Left</button>
          <button type="button" data-action="rotate">Rotate</button>
          <button type="button" data-action="right">Right</button>
          <button type="button" data-action="soft-drop">Soft Drop</button>
          <button type="button" data-action="hard-drop">Hard Drop</button>
          <button type="button" data-action="hold">Hold</button>
        </div>
      </div>

      <aside class="card space-y-6">
        <div class="grid grid-cols-2 gap-4">
          <div>
            <h2 class="text-xl font-semibold text-textMain">Next</h2>
            <canvas id="next-canvas" width="120" height="120" class="mt-2 rounded-lg panel-canvas"></canvas>
          </div>
          <div>
            <h2 class="text-xl font-semibold text-textMain">Hold</h2>
            <canvas id="hold-canvas" width="120" height="120" class="mt-2 rounded-lg panel-canvas"></canvas>
          </div>
        </div>

        <div>
          <p class="metric-label">Score</p>
          <p id="score-display" class="text-3xl font-semibold text-textMain">0</p>
        </div>

        <div>
          <p class="metric-label">HIGH SCORE</p>
          <p id="high-score-display" class="text-xl font-semibold text-textMain">0</p>
        </div>

        <div>
          <p class="metric-label">Lines</p>
          <p id="lines-display" class="text-xl font-semibold text-textMain">0</p>
        </div>

        <div>
          <p class="metric-label">Level</p>
          <p id="level-display" class="text-xl font-semibold text-textMain">1</p>
        </div>

        <div>
          <p class="metric-label mb-2">Mode</p>
          <div class="flex gap-2">
            <button id="mode-classic" class="mode-btn active" type="button">Classic</button>
            <button id="mode-chaos" class="mode-btn" type="button">Chaos</button>
          </div>
          <p id="mode-desc" class="text-xs text-textMuted mt-1">Clean board, pure skill.</p>
        </div>

        <div class="flex gap-3">
          <button id="start-btn" class="btn-primary" type="button">Start</button>
          <button id="pause-btn" class="btn-secondary" type="button">Pause</button>
          <button id="mute-btn" class="btn-secondary text-sm" type="button">Sound</button>
        </div>

        <div class="space-y-1 text-sm text-textMuted">
          <p><kbd class="rounded border border-borderTone bg-panel px-1.5 py-0.5 text-xs">←</kbd> <kbd class="rounded border border-borderTone bg-panel px-1.5 py-0.5 text-xs">→</kbd> Move</p>
          <p><kbd class="rounded border border-borderTone bg-panel px-1.5 py-0.5 text-xs">↑</kbd> Rotate</p>
          <p><kbd class="rounded border border-borderTone bg-panel px-1.5 py-0.5 text-xs">↓</kbd> Soft drop</p>
          <p><kbd class="rounded border border-borderTone bg-panel px-1.5 py-0.5 text-xs">Space</kbd> Hard drop</p>
          <p><kbd class="rounded border border-borderTone bg-panel px-1.5 py-0.5 text-xs">C</kbd> Hold</p>
          <p class="pt-1 text-xs">Touch: tap rotate, swipe left/right move, swipe down soft drop, swipe up hard drop.</p>
        </div>
      </aside>
    </div>
  </section>

  <script type="module">
    const canvas = document.getElementById('tetris-canvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next-canvas');
    const nextCtx = nextCanvas.getContext('2d');
    const holdCanvas = document.getElementById('hold-canvas');
    const holdCtx = holdCanvas.getContext('2d');
    const tspinBanner = document.getElementById('tspin-banner');
    const touchControls = document.getElementById('touch-controls');
    const scoreDisplay = document.getElementById('score-display');
    const highScoreDisplay = document.getElementById('high-score-display');
    const linesDisplay = document.getElementById('lines-display');
    const levelDisplay = document.getElementById('level-display');
    const startBtn = document.getElementById('start-btn');
    const pauseBtn = document.getElementById('pause-btn');

    const COLS = 10;
    const ROWS = 20;
    const BLOCK = 30;
    const PREVIEW_BLOCK = 24;
    const HIGH_SCORE_KEY = 'tetris-high-score-v1';
    const FLASH_DURATION = 200;
    const SLIDE_DURATION = 120;

    const COLORS = {
      I: '#14b8a6',
      O: '#f59e0b',
      T: '#8b5cf6',
      S: '#10b981',
      Z: '#ef4444',
      J: '#3b82f6',
      L: '#f97316'
    };

    const SHAPES = {
      I: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      O: [
        [1, 1],
        [1, 1]
      ],
      T: [
        [0, 1, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      S: [
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0]
      ],
      Z: [
        [1, 1, 0],
        [0, 1, 1],
        [0, 0, 0]
      ],
      J: [
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      L: [
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 0]
      ]
    };

    const JLSTZ_KICKS = {
      '0>1': [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
      '1>2': [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
      '2>3': [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
      '3>0': [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]]
    };

    const I_KICKS = {
      '0>1': [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2]],
      '1>2': [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1]],
      '2>3': [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2]],
      '3>0': [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1]]
    };

    const PIECE_NAMES = Object.keys(SHAPES);

    let board = [];
    let currentPiece = null;
    let nextPiece = null;
    let holdPieceName = null;
    let canHold = true;
    let score = 0;
    let highScore = loadHighScore();
    let lines = 0;
    let level = 1;
    let gameOver = false;
    let paused = false;
    let started = false;
    let dropInterval = 800;
    let lastDrop = 0;
    let lastFrame = 0;
    let animFrame = null;
    let lastRotateSuccessful = false;
    let lineClearAnimation = null;
    let particles = [];
    let tspinUntil = 0;
    let lastSoftDropTone = 0;

    let audioCtx = null;
    let masterGain = null;
    let muted = false;
    let chaosMode = false;
    const AudioConstructor = window.AudioContext || window.webkitAudioContext;

    function cloneShape(shape) {
      return shape.map((row) => [...row]);
    }

    function createBoard() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function addGarbageRows(count) {
      const colors = Object.values(COLORS);
      for (let i = 0; i < count; i++) {
        const row = Array.from({ length: COLS }, () => {
          return Math.random() < 0.6 ? colors[Math.floor(Math.random() * colors.length)] : 0;
        });
        const gap1 = Math.floor(Math.random() * COLS);
        const gap2 = Math.floor(Math.random() * COLS);
        row[gap1] = 0;
        row[gap2] = 0;
        board[ROWS - 1 - i] = row;
      }
    }

    function randomPieceName() {
      return PIECE_NAMES[Math.floor(Math.random() * PIECE_NAMES.length)];
    }

    function createPiece(name = randomPieceName()) {
      const shape = cloneShape(SHAPES[name]);
      return {
        name,
        shape,
        color: COLORS[name],
        x: Math.floor((COLS - shape[0].length) / 2),
        y: name === 'I' ? -1 : 0,
        rotation: 0
      };
    }

    function ensureAudio() {
      if (!AudioConstructor) return;
      if (!audioCtx) {
        audioCtx = new AudioConstructor();
        masterGain = audioCtx.createGain();
        masterGain.gain.value = 0.16;
        masterGain.connect(audioCtx.destination);
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(() => {});
      }
    }

    function tone(freq, duration, startOffset = 0, type = 'square', volume = 0.05) {
      if (!audioCtx || !masterGain || muted) return;
      const startAt = audioCtx.currentTime + startOffset;
      const oscillator = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      oscillator.type = type;
      oscillator.frequency.setValueAtTime(freq, startAt);
      gain.gain.setValueAtTime(0.0001, startAt);
      gain.gain.exponentialRampToValueAtTime(volume, startAt + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, startAt + duration);
      oscillator.connect(gain);
      gain.connect(masterGain);
      oscillator.start(startAt);
      oscillator.stop(startAt + duration + 0.03);
    }

    function playMoveSound() {
      tone(880, 0.03, 0, 'square', 0.025);
      tone(1100, 0.02, 0.02, 'square', 0.015);
    }

    function playDropSound() {
      tone(220, 0.05, 0, 'square', 0.04);
      tone(110, 0.06, 0.03, 'square', 0.03);
    }

    function playLockSound() {
      tone(180, 0.06, 0, 'triangle', 0.04);
      tone(90, 0.08, 0.04, 'triangle', 0.03);
    }

    function playLineClearSound(cleared) {
      // Ascending arpeggio — more notes for more lines
      const base = cleared === 4 ? [523, 659, 784, 1047, 1319] : [440, 554, 659, 880];
      for (let i = 0; i < base.length; i++) {
        tone(base[i], 0.1, i * 0.05, 'square', 0.04);
      }
      if (cleared === 4) {
        // Tetris! Extra fanfare
        tone(1568, 0.15, 0.28, 'square', 0.05);
        tone(2093, 0.2, 0.38, 'triangle', 0.04);
      }
    }

    function playGameOverSound() {
      const notes = [440, 415, 370, 330, 294, 262, 220, 165];
      for (let i = 0; i < notes.length; i++) {
        tone(notes[i], 0.12, i * 0.1, 'square', 0.04);
      }
    }

    function loadHighScore() {
      try {
        const stored = localStorage.getItem(HIGH_SCORE_KEY);
        const parsed = Number.parseInt(stored || '0', 10);
        return Number.isFinite(parsed) ? parsed : 0;
      } catch {
        return 0;
      }
    }

    function saveHighScore() {
      try {
        localStorage.setItem(HIGH_SCORE_KEY, String(highScore));
      } catch {
        // Ignore localStorage errors in private browsing / restricted contexts.
      }
    }

    function getDropFrames(effectiveLevel) {
      if (effectiveLevel <= 1) return 48;
      if (effectiveLevel <= 9) {
        const t = (effectiveLevel - 1) / 8;
        return 48 * Math.pow(6 / 48, t);
      }
      return Math.max(2, 6 * Math.pow(0.92, effectiveLevel - 9));
    }

    function updateSpeedCurve() {
      level = Math.floor(lines / 10) + 1;
      const effectiveLevel = 1 + lines / 10;
      const frames = getDropFrames(effectiveLevel);
      dropInterval = (frames / 60) * 1000;
    }

    function rotateCW(shape) {
      const size = shape.length;
      const rotated = Array.from({ length: size }, () => Array(size).fill(0));
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          rotated[c][size - 1 - r] = shape[r][c];
        }
      }
      return rotated;
    }

    function collides(piece, dx = 0, dy = 0, shape = null) {
      const s = shape || piece.shape;
      for (let r = 0; r < s.length; r++) {
        for (let c = 0; c < s[r].length; c++) {
          if (!s[r][c]) continue;
          const nx = piece.x + c + dx;
          const ny = piece.y + r + dy;
          if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
          if (ny >= 0 && board[ny][nx]) return true;
        }
      }
      return false;
    }

    function canControl() {
      return started && !paused && !gameOver && currentPiece && !lineClearAnimation;
    }

    function getKickTests(name, from, to) {
      if (name === 'O') return [[0, 0]];
      const key = `${from}>${to}`;
      const table = name === 'I' ? I_KICKS : JLSTZ_KICKS;
      return table[key] || [[0, 0]];
    }

    function attemptRotate() {
      if (!canControl()) return;
      const rotated = rotateCW(currentPiece.shape);
      const from = currentPiece.rotation;
      const to = (from + 1) % 4;

      if (!collides(currentPiece, 0, 0, rotated)) {
        currentPiece.shape = rotated;
        currentPiece.rotation = to;
        lastRotateSuccessful = true;
        playMoveSound();
        return;
      }

      const kicks = getKickTests(currentPiece.name, from, to).slice(1, 5);
      for (const [kickX, kickY] of kicks) {
        const dx = kickX;
        const dy = -kickY;
        if (!collides(currentPiece, dx, dy, rotated)) {
          currentPiece.x += dx;
          currentPiece.y += dy;
          currentPiece.shape = rotated;
          currentPiece.rotation = to;
          lastRotateSuccessful = true;
          playMoveSound();
          return;
        }
      }
      lastRotateSuccessful = false;
    }

    function movePiece(dx) {
      if (!canControl()) return;
      if (!collides(currentPiece, dx, 0)) {
        currentPiece.x += dx;
        lastRotateSuccessful = false;
        playMoveSound();
      }
    }

    function softDrop() {
      if (!canControl()) return;
      if (!collides(currentPiece, 0, 1)) {
        currentPiece.y += 1;
        score += 1;
        lastRotateSuccessful = false;
        const now = performance.now();
        if (now - lastSoftDropTone > 80) {
          playDropSound();
          lastSoftDropTone = now;
        }
      } else {
        lockPiece();
      }
    }

    function hardDrop() {
      if (!canControl()) return;
      let distance = 0;
      while (!collides(currentPiece, 0, 1)) {
        currentPiece.y++;
        distance++;
      }
      score += distance * 2;
      lastRotateSuccessful = false;
      playDropSound();
      lockPiece();
      lastDrop = performance.now();
    }

    function holdPiece() {
      if (!canControl() || !canHold) return;
      const activeName = currentPiece.name;
      if (!holdPieceName) {
        holdPieceName = activeName;
        spawnNextPiece();
      } else {
        const swapName = holdPieceName;
        holdPieceName = activeName;
        currentPiece = createPiece(swapName);
        lastDrop = performance.now();
        if (collides(currentPiece)) {
          setGameOver();
        }
      }
      canHold = false;
      lastRotateSuccessful = false;
      playMoveSound();
    }

    function findFullRows() {
      const rows = [];
      for (let r = 0; r < ROWS; r++) {
        if (board[r].every((cell) => cell !== 0)) {
          rows.push(r);
        }
      }
      return rows;
    }

    function spawnLineParticles(rows) {
      const colors = ['#14b8a6', '#e7edf8'];
      const now = performance.now();
      for (const row of rows) {
        for (let col = 0; col < COLS; col++) {
          if (!board[row][col]) continue;
          for (let i = 0; i < 4; i++) {
            particles.push({
              x: col * BLOCK + BLOCK / 2,
              y: row * BLOCK + BLOCK / 2,
              vx: (Math.random() - 0.5) * 220,
              vy: -80 - Math.random() * 220,
              size: 2 + Math.random() * 3,
              color: colors[Math.random() < 0.68 ? 0 : 1],
              born: now,
              life: 500
            });
          }
        }
      }
    }

    function detectTSpin(piece) {
      if (piece.name !== 'T' || !lastRotateSuccessful) return false;
      const centerX = piece.x + 1;
      const centerY = piece.y + 1;
      const corners = [
        [centerX - 1, centerY - 1],
        [centerX + 1, centerY - 1],
        [centerX - 1, centerY + 1],
        [centerX + 1, centerY + 1]
      ];

      let blocked = 0;
      for (const [x, y] of corners) {
        if (x < 0 || x >= COLS || y < 0 || y >= ROWS || board[y][x]) {
          blocked++;
        }
      }
      return blocked >= 3;
    }

    function showTSpinBanner() {
      tspinUntil = performance.now() + 900;
    }

    function startLineClearAnimation(rows, tSpin) {
      const sortedRows = [...rows].sort((a, b) => a - b);
      const rowSet = new Set(sortedRows);
      const clearedBelow = Array(ROWS).fill(0);
      let clearedCount = 0;

      for (let r = ROWS - 1; r >= 0; r--) {
        if (rowSet.has(r)) clearedCount++;
        clearedBelow[r] = clearedCount;
      }

      lineClearAnimation = {
        start: performance.now(),
        rows: sortedRows,
        rowSet,
        clearedBelow,
        snapshot: board.map((row) => [...row]),
        tSpin,
        flashDuration: FLASH_DURATION,
        slideDuration: SLIDE_DURATION
      };

      spawnLineParticles(sortedRows);
      playLineClearSound(sortedRows.length);
    }

    function finishLineClearAnimation() {
      if (!lineClearAnimation) return;
      const cleared = lineClearAnimation.rows.length;

      for (let i = lineClearAnimation.rows.length - 1; i >= 0; i--) {
        board.splice(lineClearAnimation.rows[i], 1);
        board.unshift(Array(COLS).fill(0));
      }

      const linePoints = [0, 100, 300, 500, 800];
      score += (linePoints[cleared] || 800) * level;

      if (lineClearAnimation.tSpin) {
        const tSpinBonus = { 1: 400, 2: 800, 3: 1200 };
        score += tSpinBonus[cleared] || 0;
      }

      lines += cleared;
      updateSpeedCurve();
      lineClearAnimation = null;
      spawnNextPiece();
    }

    function lockPiece() {
      if (!currentPiece || gameOver) return;
      playLockSound();

      for (let r = 0; r < currentPiece.shape.length; r++) {
        for (let c = 0; c < currentPiece.shape[r].length; c++) {
          if (!currentPiece.shape[r][c]) continue;
          const x = currentPiece.x + c;
          const y = currentPiece.y + r;
          if (y < 0) {
            setGameOver();
            return;
          }
          board[y][x] = currentPiece.color;
        }
      }

      const tSpin = detectTSpin(currentPiece);
      if (tSpin) {
        showTSpinBanner();
      }

      const fullRows = findFullRows();
      canHold = true;
      lastRotateSuccessful = false;

      if (fullRows.length > 0) {
        currentPiece = null;
        startLineClearAnimation(fullRows, tSpin);
      } else {
        spawnNextPiece();
      }
    }

    function setGameOver() {
      if (gameOver) return;
      gameOver = true;
      if (score > highScore) {
        highScore = score;
        saveHighScore();
      }
      playGameOverSound();
    }

    function spawnNextPiece() {
      if (!nextPiece) nextPiece = createPiece();
      currentPiece = createPiece(nextPiece.name);
      nextPiece = createPiece();
      lastRotateSuccessful = false;
      lastDrop = performance.now();
      if (collides(currentPiece)) {
        setGameOver();
      }
    }

    function drawBlockPx(targetCtx, px, py, color, size, options = {}) {
      const { active = false, preview = false } = options;
      targetCtx.save();
      targetCtx.shadowColor = active
        ? 'rgba(20,184,166,0.9)'
        : preview
          ? 'rgba(20,184,166,0.3)'
          : 'rgba(20,184,166,0.45)';
      targetCtx.shadowBlur = active ? 16 : preview ? 5 : 7;
      targetCtx.fillStyle = color;
      targetCtx.fillRect(px + 1.5, py + 1.5, size - 3, size - 3);
      targetCtx.shadowBlur = 0;
      targetCtx.fillStyle = 'rgba(255,255,255,0.2)';
      targetCtx.fillRect(px + 2, py + 2, size - 4, 3);
      targetCtx.fillStyle = 'rgba(0,0,0,0.16)';
      targetCtx.fillRect(px + 2, py + size - 5, size - 4, 2);
      targetCtx.restore();
    }

    function drawBlock(targetCtx, x, y, color, size, options = {}) {
      drawBlockPx(targetCtx, x * size, y * size, color, size, options);
    }

    function drawGrid() {
      ctx.strokeStyle = '#182338';
      ctx.lineWidth = 0.5;
      for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath();
        ctx.moveTo(0, r * BLOCK);
        ctx.lineTo(COLS * BLOCK, r * BLOCK);
        ctx.stroke();
      }
      for (let c = 0; c <= COLS; c++) {
        ctx.beginPath();
        ctx.moveTo(c * BLOCK, 0);
        ctx.lineTo(c * BLOCK, ROWS * BLOCK);
        ctx.stroke();
      }
    }

    function drawLockedBoard(now) {
      if (!lineClearAnimation) {
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (board[r][c]) drawBlock(ctx, c, r, board[r][c], BLOCK);
          }
        }
        return;
      }

      const elapsed = now - lineClearAnimation.start;
      if (elapsed < lineClearAnimation.flashDuration) {
        const flashOn = Math.floor(elapsed / 50) % 2 === 0;
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const cell = lineClearAnimation.snapshot[r][c];
            if (!cell) continue;
            const color = lineClearAnimation.rowSet.has(r) && flashOn ? '#ffffff' : cell;
            drawBlock(ctx, c, r, color, BLOCK);
          }
        }
      } else {
        const progress = Math.min(
          1,
          (elapsed - lineClearAnimation.flashDuration) / lineClearAnimation.slideDuration
        );
        for (let r = 0; r < ROWS; r++) {
          if (lineClearAnimation.rowSet.has(r)) continue;
          const shift = lineClearAnimation.clearedBelow[r];
          const drawY = (r + shift * progress) * BLOCK;
          for (let c = 0; c < COLS; c++) {
            const cell = lineClearAnimation.snapshot[r][c];
            if (!cell) continue;
            drawBlockPx(ctx, c * BLOCK, drawY, cell, BLOCK);
          }
        }
      }
    }

    function drawGhostPiece() {
      if (!currentPiece || lineClearAnimation || gameOver) return;
      let drop = 0;
      while (!collides(currentPiece, 0, drop + 1)) {
        drop++;
      }

      ctx.save();
      ctx.strokeStyle = 'rgba(20,184,166,0.78)';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 4]);
      for (let r = 0; r < currentPiece.shape.length; r++) {
        for (let c = 0; c < currentPiece.shape[r].length; c++) {
          if (!currentPiece.shape[r][c]) continue;
          const gx = currentPiece.x + c;
          const gy = currentPiece.y + r + drop;
          if (gy < 0) continue;
          ctx.strokeRect(gx * BLOCK + 5, gy * BLOCK + 5, BLOCK - 10, BLOCK - 10);
        }
      }
      ctx.restore();
    }

    function drawCurrentPiece() {
      if (!currentPiece || lineClearAnimation || gameOver) return;
      for (let r = 0; r < currentPiece.shape.length; r++) {
        for (let c = 0; c < currentPiece.shape[r].length; c++) {
          if (!currentPiece.shape[r][c]) continue;
          const x = currentPiece.x + c;
          const y = currentPiece.y + r;
          if (y < 0) continue;
          drawBlock(ctx, x, y, currentPiece.color, BLOCK, { active: true });
        }
      }
    }

    function drawParticles(now) {
      if (particles.length === 0) return;
      ctx.save();
      for (const particle of particles) {
        const age = now - particle.born;
        const lifeRatio = 1 - age / particle.life;
        if (lifeRatio <= 0) continue;
        ctx.globalAlpha = lifeRatio;
        ctx.fillStyle = particle.color;
        ctx.shadowColor = particle.color;
        ctx.shadowBlur = 8;
        ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
      }
      ctx.restore();
    }

    function updateParticles(dt, now) {
      particles = particles.filter((particle) => {
        const age = now - particle.born;
        if (age > particle.life) return false;
        particle.vy += 620 * dt;
        particle.x += particle.vx * dt;
        particle.y += particle.vy * dt;
        return true;
      });
    }

    function getShapeBounds(shape) {
      let minR = shape.length;
      let maxR = -1;
      let minC = shape[0].length;
      let maxC = -1;

      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (!shape[r][c]) continue;
          if (r < minR) minR = r;
          if (r > maxR) maxR = r;
          if (c < minC) minC = c;
          if (c > maxC) maxC = c;
        }
      }

      return {
        minR,
        maxR,
        minC,
        maxC,
        width: maxC - minC + 1,
        height: maxR - minR + 1
      };
    }

    function drawPreview(targetCtx, targetCanvas, pieceName) {
      targetCtx.fillStyle = '#0a0f1a';
      targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
      if (!pieceName) return;

      const shape = SHAPES[pieceName];
      const bounds = getShapeBounds(shape);
      const drawWidth = bounds.width * PREVIEW_BLOCK;
      const drawHeight = bounds.height * PREVIEW_BLOCK;
      const startX = Math.floor((targetCanvas.width - drawWidth) / 2);
      const startY = Math.floor((targetCanvas.height - drawHeight) / 2);

      for (let r = bounds.minR; r <= bounds.maxR; r++) {
        for (let c = bounds.minC; c <= bounds.maxC; c++) {
          if (!shape[r][c]) continue;
          const x = startX + (c - bounds.minC) * PREVIEW_BLOCK;
          const y = startY + (r - bounds.minR) * PREVIEW_BLOCK;
          drawBlockPx(targetCtx, x, y, COLORS[pieceName], PREVIEW_BLOCK, { preview: true });
        }
      }
    }

    function drawNext() {
      drawPreview(nextCtx, nextCanvas, nextPiece ? nextPiece.name : null);
    }

    function drawHold() {
      drawPreview(holdCtx, holdCanvas, holdPieceName);
    }

    function updateUI() {
      scoreDisplay.textContent = score.toLocaleString();
      highScoreDisplay.textContent = highScore.toLocaleString();
      linesDisplay.textContent = lines;
      levelDisplay.textContent = level;
    }

    function drawBoard(now) {
      ctx.fillStyle = '#0a0f1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      drawGrid();
      drawLockedBoard(now);
      drawGhostPiece();
      drawCurrentPiece();
      drawParticles(now);

      if (paused && !gameOver) {
        ctx.fillStyle = 'rgba(9,13,20,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#e7edf8';
        ctx.textAlign = 'center';
        ctx.font = '700 26px "Trebuchet MS", sans-serif';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
      }

      if (gameOver) {
        ctx.fillStyle = 'rgba(9,13,20,0.85)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#e7edf8';
        ctx.textAlign = 'center';
        ctx.font = '700 28px "Trebuchet MS", sans-serif';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 14);
        ctx.font = '16px "Trebuchet MS", sans-serif';
        ctx.fillStyle = '#9aa8bf';
        ctx.fillText(`Score: ${score.toLocaleString()}`, canvas.width / 2, canvas.height / 2 + 16);
        ctx.fillText('Press Start to play again', canvas.width / 2, canvas.height / 2 + 42);
      }

      tspinBanner.classList.toggle('is-visible', now < tspinUntil);
    }

    function updateLineClearAnimation(now) {
      if (!lineClearAnimation) return;
      const total = lineClearAnimation.flashDuration + lineClearAnimation.slideDuration;
      if (now - lineClearAnimation.start >= total) {
        finishLineClearAnimation();
      }
    }

    function safetyCheckClearRows() {
      // Belt-and-suspenders: if any full rows exist on board, clear them immediately
      if (lineClearAnimation) return;
      let cleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every((cell) => cell !== 0)) {
          board.splice(r, 1);
          board.unshift(Array(COLS).fill(0));
          cleared++;
          r++; // recheck this index
        }
      }
      if (cleared > 0) {
        const linePoints = [0, 100, 300, 500, 800];
        score += (linePoints[cleared] || 800) * level;
        lines += cleared;
        updateSpeedCurve();
        playLineClearSound(cleared);
      }
    }

    function gameLoop(time) {
      if (!started) return;

      const dt = lastFrame ? Math.min(0.05, (time - lastFrame) / 1000) : 0;
      lastFrame = time;

      if (!paused && !gameOver) {
        if (lineClearAnimation) {
          updateLineClearAnimation(time);
        } else if (currentPiece && time - lastDrop >= dropInterval) {
          if (!collides(currentPiece, 0, 1)) {
            currentPiece.y++;
          } else {
            lockPiece();
          }
          lastDrop = time;
        }
      }

      if (!paused && !gameOver) safetyCheckClearRows();
      updateParticles(dt, time);
      drawBoard(time);
      drawNext();
      drawHold();
      updateUI();
      animFrame = requestAnimationFrame(gameLoop);
    }

    function startGame() {
      ensureAudio();
      createBoard();
      if (chaosMode) addGarbageRows(4 + Math.floor(Math.random() * 3));
      score = 0;
      lines = 0;
      level = 1;
      holdPieceName = null;
      canHold = true;
      gameOver = false;
      paused = false;
      started = true;
      particles = [];
      lineClearAnimation = null;
      tspinUntil = 0;
      lastRotateSuccessful = false;
      updateSpeedCurve();

      nextPiece = createPiece();
      spawnNextPiece();

      lastDrop = performance.now();
      lastFrame = lastDrop;
      pauseBtn.textContent = 'Pause';
      startBtn.textContent = 'Restart';

      if (animFrame) cancelAnimationFrame(animFrame);
      animFrame = requestAnimationFrame(gameLoop);
    }

    function togglePause() {
      if (!started || gameOver) return;
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      if (!paused) {
        lastDrop = performance.now();
      }
    }

    function handleAction(action) {
      if (!canControl()) return;
      ensureAudio();
      switch (action) {
        case 'left':
          movePiece(-1);
          break;
        case 'right':
          movePiece(1);
          break;
        case 'rotate':
          attemptRotate();
          break;
        case 'soft-drop':
          softDrop();
          break;
        case 'hard-drop':
          hardDrop();
          break;
        case 'hold':
          holdPiece();
          break;
      }
    }

    const muteBtn = document.getElementById('mute-btn');
    const modeClassicBtn = document.getElementById('mode-classic');
    const modeChaosBtn = document.getElementById('mode-chaos');
    const modeDesc = document.getElementById('mode-desc');

    modeClassicBtn.addEventListener('click', () => {
      chaosMode = false;
      modeClassicBtn.classList.add('active');
      modeChaosBtn.classList.remove('active');
      modeDesc.textContent = 'Clean board, pure skill.';
    });

    modeChaosBtn.addEventListener('click', () => {
      chaosMode = true;
      modeChaosBtn.classList.add('active');
      modeClassicBtn.classList.remove('active');
      modeDesc.textContent = 'Start with random garbage rows.';
    });

    function toggleMute() {
      muted = !muted;
      muteBtn.textContent = muted ? 'Unmute' : 'Sound';
    }

    startBtn.addEventListener('click', startGame);
    pauseBtn.addEventListener('click', togglePause);
    muteBtn.addEventListener('click', toggleMute);

    document.addEventListener('keydown', (e) => {
      const controls = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', ' ', 'c', 'C'];
      if (controls.includes(e.key)) e.preventDefault();
      if (!canControl()) return;
      ensureAudio();

      switch (e.key) {
        case 'ArrowLeft':
          movePiece(-1);
          break;
        case 'ArrowRight':
          movePiece(1);
          break;
        case 'ArrowDown':
          softDrop();
          break;
        case 'ArrowUp':
          attemptRotate();
          break;
        case ' ':
          hardDrop();
          break;
        case 'c':
        case 'C':
          holdPiece();
          break;
      }
    });

    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;

    canvas.addEventListener('touchstart', (e) => {
      if (!canControl()) return;
      ensureAudio();
      const touch = e.changedTouches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      touchStartTime = performance.now();
    }, { passive: true });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (!canControl()) return;
      const touch = e.changedTouches[0];
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      const elapsed = performance.now() - touchStartTime;
      const swipeThreshold = 24;

      if (absX < 10 && absY < 10 && elapsed < 280) {
        attemptRotate();
      } else if (absX > absY) {
        if (dx > swipeThreshold) movePiece(1);
        if (dx < -swipeThreshold) movePiece(-1);
      } else {
        if (dy > swipeThreshold) softDrop();
        if (dy < -swipeThreshold) hardDrop();
      }
      e.preventDefault();
    }, { passive: false });

    touchControls.querySelectorAll('button[data-action]').forEach((button) => {
      button.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        const action = button.dataset.action;
        handleAction(action);
      });
    });

    createBoard();
    drawBoard(performance.now());
    drawNext();
    drawHold();
    updateUI();
    ctx.fillStyle = '#9aa8bf';
    ctx.font = '18px "Trebuchet MS", sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Press Start to play', canvas.width / 2, canvas.height / 2);
  </script>
  <style>
    .tetris-playfield {
      background: #0a0f1a;
      border: 2px solid #2b3850;
      touch-action: none;
    }

    .panel-canvas {
      background: #0a0f1a;
      border: 1px solid #2b3850;
    }

    .tspin-banner {
      position: absolute;
      top: 0.75rem;
      left: 50%;
      transform: translateX(-50%) scale(0.92);
      padding: 0.2rem 0.65rem;
      border-radius: 9999px;
      border: 1px solid rgba(20, 184, 166, 0.7);
      color: #e7edf8;
      background: rgba(20, 184, 166, 0.16);
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      font-weight: 700;
      opacity: 0;
      pointer-events: none;
      transition: opacity 120ms ease, transform 120ms ease;
      text-shadow: 0 0 10px rgba(20, 184, 166, 0.65);
    }

    .tspin-banner.is-visible {
      opacity: 1;
      transform: translateX(-50%) scale(1);
    }

    .mode-btn {
      padding: 0.4rem 0.8rem;
      border-radius: 0.5rem;
      border: 1px solid #2b3850;
      background: #101726;
      color: #9aa8bf;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .mode-btn.active {
      border-color: #14b8a6;
      color: #e7edf8;
      background: rgba(20, 184, 166, 0.14);
    }

    .mode-btn:hover {
      border-color: #14b8a6;
    }

    .touch-controls {
      display: none;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 0.5rem;
      touch-action: manipulation;
    }

    .touch-controls button {
      padding: 0.6rem 0.4rem;
      border-radius: 0.6rem;
      border: 1px solid #2b3850;
      background: #101a2b;
      color: #e7edf8;
      font-size: 0.78rem;
      font-weight: 600;
      letter-spacing: 0.02em;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .touch-controls button:active {
      border-color: #14b8a6;
      background: #15283e;
      box-shadow: 0 0 8px rgba(20, 184, 166, 0.42);
    }

    @media (max-width: 1024px) {
      .touch-controls {
        display: grid;
      }
    }
  </style>
</MainLayout>
