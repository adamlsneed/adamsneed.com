---
import MainLayout from '../layouts/MainLayout.astro';
import workflow from '../data/agentFlow.json';

const policies = {
  router:
    'Classifies intent, validates schema, and routes requests only to authorized specialists with explicit context boundaries.',
  'specialist-a':
    'Performs deep technical reasoning with constrained tools; must return structured findings and confidence score.',
  'specialist-b':
    'Runs alternate analysis strategy for redundancy; cannot execute changes and must emit verifiable evidence.',
  'human-review':
    'Approval gate enforces human-in-the-loop control for high-impact operations and policy exceptions.',
  execute:
    'Applies approved action set, logs execution details, and emits immutable audit events to downstream systems.',
  feedback:
    'Routes rejected outcomes to remediation loop, updates prompts/rules, and retries after policy-compliant corrections.'
};
---

<MainLayout
  title="Lab"
  description="Interactive Agent Flow Visualizer showing multi-agent request routing, policy gates, and outcome loops."
>
  <section class="space-y-8">
    <div class="max-w-4xl space-y-4">
      <p class="eyebrow">Lab</p>
      <h1 class="section-title">Agent Flow Visualizer</h1>
      <p class="lead">
        Simulate how a request moves through a production-style multi-agent chain. Start the flow, watch execution paths,
        and inspect node-level policies.
      </p>
    </div>

    <div class="grid gap-6 lg:grid-cols-[2fr,1fr]">
      <div class="card space-y-4">
        <div class="flex flex-wrap gap-3">
          <button id="flow-start" class="btn-primary" type="button">Start Flow</button>
          <button id="flow-reset" class="btn-secondary" type="button">Reset</button>
        </div>
        <div class="overflow-hidden rounded-xl border border-borderTone/80 bg-slate-950/50">
          <svg
            id="flow-svg"
            viewBox="0 0 560 600"
            class="h-auto w-full"
            role="img"
            aria-labelledby="flow-diagram-title flow-diagram-desc"
          >
            <title id="flow-diagram-title">Agent flow sequence diagram</title>
            <desc id="flow-diagram-desc">
              Request routed from a router agent to specialist agents, then through human review to execution or feedback.
            </desc>
            <defs>
              <marker id="flow-arrow" markerWidth="8" markerHeight="8" refX="6" refY="4" orient="auto">
                <path d="M0,0 L8,4 L0,8 Z" fill="#4b5d7d"></path>
              </marker>
            </defs>
          </svg>
        </div>
      </div>

      <aside class="card space-y-4">
        <h2 class="text-xl font-semibold">Node Policy</h2>
        <p id="policy-node" class="font-semibold text-accent">Router Agent</p>
        <p id="policy-text" class="text-sm text-textMuted">Click any node to inspect how policy constraints are enforced.</p>
        <div>
          <h3 class="metric-label mb-2">Simulation Log</h3>
          <ul id="flow-log" class="space-y-2 text-sm text-textMuted"></ul>
        </div>
      </aside>
    </div>
  </section>

  <script id="flow-data" type="application/json">{JSON.stringify(workflow)}</script>
  <script id="flow-policies" type="application/json">{JSON.stringify(policies)}</script>

  <script type="module">
    (() => {
      const dataEl = document.getElementById('flow-data');
      const policyEl = document.getElementById('flow-policies');
      const svg = document.getElementById('flow-svg');
      const startBtn = document.getElementById('flow-start');
      const resetBtn = document.getElementById('flow-reset');
      const policyNode = document.getElementById('policy-node');
      const policyText = document.getElementById('policy-text');
      const flowLog = document.getElementById('flow-log');

      if (!(dataEl && policyEl && svg && startBtn && resetBtn && policyNode && policyText && flowLog)) {
        return;
      }

      const flowData = JSON.parse(dataEl.textContent || '{"nodes":[],"edges":[]}');
      const policies = JSON.parse(policyEl.textContent || '{}');
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const svgNS = 'http://www.w3.org/2000/svg';

      const positions = {
        router: { x: 280, y: 80 },
        'specialist-a': { x: 150, y: 225 },
        'specialist-b': { x: 410, y: 225 },
        'human-review': { x: 280, y: 360 },
        execute: { x: 150, y: 510 },
        feedback: { x: 410, y: 510 }
      };

      const nodeLayer = document.createElementNS(svgNS, 'g');
      const edgeLayer = document.createElementNS(svgNS, 'g');
      const dotLayer = document.createElementNS(svgNS, 'g');
      svg.append(edgeLayer, nodeLayer, dotLayer);

      const nodeElements = new Map();
      const edgeElements = new Map();

      const sleep = (ms) => new Promise((resolve) => window.setTimeout(resolve, ms));

      function appendLog(message) {
        const item = document.createElement('li');
        item.className = 'rounded-md border border-borderTone/70 bg-surface-soft px-3 py-2';
        item.textContent = message;
        flowLog.prepend(item);
        while (flowLog.children.length > 7) {
          flowLog.removeChild(flowLog.lastChild);
        }
      }

      function splitLabel(label) {
        const words = label.split(' ');
        if (words.length <= 2) return [label];
        const first = words.slice(0, Math.ceil(words.length / 2)).join(' ');
        const second = words.slice(Math.ceil(words.length / 2)).join(' ');
        return [first, second];
      }

      function setPolicy(nodeId) {
        const node = flowData.nodes.find((item) => item.id === nodeId);
        if (!node) return;
        nodeElements.forEach((group, id) => {
          group.classList.toggle('selected', id === nodeId);
        });
        policyNode.textContent = node.label;
        policyText.textContent = policies[nodeId] || 'No policy information available.';
      }

      function drawEdge(edge) {
        const from = positions[edge.from];
        const to = positions[edge.to];
        if (!from || !to) return;

        const group = document.createElementNS(svgNS, 'g');
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('x1', String(from.x));
        line.setAttribute('y1', String(from.y));
        line.setAttribute('x2', String(to.x));
        line.setAttribute('y2', String(to.y));
        line.setAttribute('marker-end', 'url(#flow-arrow)');
        line.classList.add('flow-edge');

        group.append(line);

        if (edge.label) {
          const label = document.createElementNS(svgNS, 'text');
          label.setAttribute('x', String((from.x + to.x) / 2));
          label.setAttribute('y', String((from.y + to.y) / 2 - 8));
          label.setAttribute('text-anchor', 'middle');
          label.classList.add('flow-label');
          label.textContent = edge.label;
          group.append(label);
        }

        edgeLayer.append(group);

        edgeElements.set(`${edge.from}->${edge.to}`, {
          line,
          from,
          to
        });
      }

      function drawNode(node) {
        const point = positions[node.id];
        if (!point) return;

        const group = document.createElementNS(svgNS, 'g');
        group.classList.add('flow-node');
        group.dataset.nodeId = node.id;
        group.setAttribute('tabindex', '0');
        group.setAttribute('role', 'button');
        group.setAttribute('aria-label', `Show policy for ${node.label}`);

        const shapeClass = `shape shape-${node.type}`;

        if (node.type === 'agent') {
          const circle = document.createElementNS(svgNS, 'circle');
          circle.setAttribute('cx', String(point.x));
          circle.setAttribute('cy', String(point.y));
          circle.setAttribute('r', '38');
          circle.setAttribute('class', shapeClass);
          group.append(circle);
        } else if (node.type === 'gate') {
          const diamond = document.createElementNS(svgNS, 'polygon');
          diamond.setAttribute(
            'points',
            `${point.x},${point.y - 42} ${point.x + 42},${point.y} ${point.x},${point.y + 42} ${point.x - 42},${point.y}`
          );
          diamond.setAttribute('class', shapeClass);
          group.append(diamond);
        } else {
          const rect = document.createElementNS(svgNS, 'rect');
          rect.setAttribute('x', String(point.x - 52));
          rect.setAttribute('y', String(point.y - 30));
          rect.setAttribute('width', '104');
          rect.setAttribute('height', '60');
          rect.setAttribute('rx', '14');
          rect.setAttribute('class', shapeClass);
          group.append(rect);
        }

        const lines = splitLabel(node.label);
        lines.forEach((line, index) => {
          const label = document.createElementNS(svgNS, 'text');
          label.setAttribute('x', String(point.x));
          label.setAttribute('y', String(point.y + (index - (lines.length - 1) / 2) * 16 + 5));
          label.setAttribute('text-anchor', 'middle');
          label.setAttribute('class', 'flow-node-label');
          label.textContent = line;
          group.append(label);
        });

        const onSelect = () => setPolicy(node.id);
        group.addEventListener('click', onSelect);
        group.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            onSelect();
          }
        });

        nodeLayer.append(group);
        nodeElements.set(node.id, group);
      }

      function clearVisualState() {
        nodeElements.forEach((group) => group.classList.remove('active'));
        edgeElements.forEach((edge) => edge.line.classList.remove('active'));
        dotLayer.replaceChildren();
      }

      async function activateNode(nodeId, message) {
        const node = nodeElements.get(nodeId);
        if (!node) return;
        node.classList.add('active');
        setPolicy(nodeId);
        if (message) appendLog(message);
        await sleep(prefersReducedMotion ? 240 : 420);
      }

      async function animateEdge(from, to, message) {
        const edge = edgeElements.get(`${from}->${to}`);
        if (!edge) return;

        edge.line.classList.add('active');
        if (message) appendLog(message);

        if (prefersReducedMotion) {
          await sleep(280);
          return;
        }

        const dot = document.createElementNS(svgNS, 'circle');
        dot.setAttribute('r', '4.6');
        dot.setAttribute('class', 'flow-dot');
        dotLayer.append(dot);

        await new Promise((resolve) => {
          const start = performance.now();
          const duration = 760;

          const tick = (time) => {
            const progress = Math.min((time - start) / duration, 1);
            const x = edge.from.x + (edge.to.x - edge.from.x) * progress;
            const y = edge.from.y + (edge.to.y - edge.from.y) * progress;
            dot.setAttribute('cx', String(x));
            dot.setAttribute('cy', String(y));

            if (progress < 1) {
              window.requestAnimationFrame(tick);
            } else {
              dot.remove();
              resolve();
            }
          };

          window.requestAnimationFrame(tick);
        });
      }

      let running = false;

      async function runSimulation() {
        if (running) return;
        running = true;
        startBtn.setAttribute('aria-busy', 'true');
        startBtn.textContent = 'Running...';
        clearVisualState();
        appendLog('Simulation started.');

        await activateNode('router', 'Router receives request envelope.');
        await animateEdge('router', 'specialist-a', 'Router dispatches to Specialist A.');
        await activateNode('specialist-a', 'Specialist A completes first-pass analysis.');
        await animateEdge('router', 'specialist-b', 'Router dispatches to Specialist B.');
        await activateNode('specialist-b', 'Specialist B returns alternate recommendation.');
        await animateEdge('specialist-a', 'human-review', 'Specialist A evidence sent to review gate.');
        await animateEdge('specialist-b', 'human-review', 'Specialist B evidence sent to review gate.');
        await activateNode('human-review', 'Human reviewer validates confidence and policy fit.');

        const approved = Math.random() >= 0.35;
        if (approved) {
          await animateEdge('human-review', 'execute', 'Request approved for execution.');
          await activateNode('execute', 'Execution agent commits controlled action.');
        } else {
          await animateEdge('human-review', 'feedback', 'Request rejected and sent to feedback loop.');
          await activateNode('feedback', 'Feedback loop records correction tasks and retry metadata.');
        }

        appendLog('Simulation complete.');
        running = false;
        startBtn.removeAttribute('aria-busy');
        startBtn.textContent = 'Start Flow';
      }

      function resetSimulation() {
        running = false;
        clearVisualState();
        flowLog.replaceChildren();
        setPolicy('router');
        appendLog('State reset. Ready for a new run.');
        startBtn.removeAttribute('aria-busy');
        startBtn.textContent = 'Start Flow';
      }

      flowData.edges.forEach(drawEdge);
      flowData.nodes.forEach(drawNode);
      setPolicy('router');
      appendLog('Visualizer initialized.');

      startBtn.addEventListener('click', () => {
        runSimulation();
      });

      resetBtn.addEventListener('click', resetSimulation);
    })();
  </script>

  <style>
    .flow-edge {
      stroke: #4b5d7d;
      stroke-width: 2;
      transition: stroke 0.3s ease, stroke-width 0.3s ease;
    }

    .flow-edge.active {
      stroke: #14b8a6;
      stroke-width: 3;
    }

    .flow-label {
      fill: #9aa8bf;
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .flow-node {
      cursor: pointer;
    }

    .shape {
      fill: rgba(19, 31, 50, 0.96);
      stroke: #445571;
      stroke-width: 2;
      transition: fill 0.2s ease, stroke 0.2s ease, transform 0.2s ease;
    }

    .flow-node.active .shape {
      fill: rgba(233, 69, 96, 0.26);
      stroke: #14b8a6;
      animation: pulse-node 1.1s ease-in-out infinite;
    }

    .flow-node.selected .shape {
      stroke: #0d9488;
      stroke-width: 3;
    }

    .flow-node-label {
      fill: #e7edf8;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.01em;
      pointer-events: none;
    }

    .flow-dot {
      fill: #99f6e4;
      filter: drop-shadow(0 0 8px rgba(233, 69, 96, 0.8));
    }

    @keyframes pulse-node {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.02);
      }
      100% {
        transform: scale(1);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .flow-node.active .shape {
        animation: none;
      }
    }
  </style>
</MainLayout>
